SINGLY LINKED LISTS

Two classes needed to implement a singly linked list:
Node Class
LinkedList Class

NODE CLASS 

Contains data and a pointer to next node or None

EXAMPLE:

class Node:
    def __init__(self, data):
        self.data = data  # Data field
        self.next_element = None  # Pointer to next node

LINKED LIST CLASS 

The linked list itself is a collection of Node objects which we 
defined above. To keep track of the list, we need a pointer to 
the first node in the list.

This is where the principle of the head node comes in. The head 
does not contain any data and only points to the beginning of the 
list. This means that, for any operations on the list, we need 
to traverse it from the head (the start of the list) to reach 
our desired node in the list.

EXAMPLE:

class LinkedList:
    def __init__(self):
        self.head_node = None  # Pointer to first node

LINKED LISTS VS LISTS 

The main difference between lists and linked lists is in the way 
elements are inserted and deleted. As for linked lists, insertion 
and deletion happen in a constant amount of time, while in the 
case of lists, it takes O(n) time to insert or delete a value. 
This is because of the different memory layout of both the data 
structures. Lists are arranged contiguously in the memory, while 
nodes of a linked list may be dispersed in the memory. This memory 
layout also affects access operation; contiguous layout of lists 
allows us to index the list thus access operation in list is O(1), 
whereas for a linked list we need to perform a traversal thus it 
becomes O(n).

CRUCIAL LINKED LIST FUNCTIONS

get_head() - returns the head of the list
insert_at_tail(data) - inserts an element at the end of the linked list
insert_at_head(data) - inserts an element at the start/head of the linked list
delete(data) - deletes an element with your specified value from the linked list
delete_at_head() - deletes the first element of the list
search(data) - searches for an element with the specified value in the linked list
is_empty() - returns true if the linked list is empty

GET HEAD + IS EMPTY EXAMPLE:

class LinkedList:
    def __init__(self):
        self.head_node = None

    def get_head(self):
        return self.head_node
    
        def is_empty(self):
        if self.head_node is None:  # Check whether the head is None
            return True
        else:
            return False


lst = LinkedList()  # Linked List created
print(lst.get_head())  # Returns None since headNode does not contain any data

PRINT LIST FUNCTION 

It simply starts at the head node, and iterates through the nodes 
using temp and displays their value. Our iteration ends when 
temp.next_element is None, which means that weâ€™ve reached the last
node in the list.

def print_list(self):
    if(self.is_empty()):
        print("List is Empty")
        return False
    temp = self.head_node
    while temp.next_element is not None:
        print(temp.data, end=" -> ")
        temp = temp.next_element
    print(temp.data, "-> None")
    return True

INSERTION

1. AT HEAD 

    # Insertion at Head
    def insert_at_head(self, data):
        # Create a new node containing your specified value
        temp_node = Node(data)
        # The new node points to the same node as the head
        temp_node.next_element = self.head_node
        self.head_node = temp_node  # Make the head point to the new node
        return self.head_node  # return the new list

2. 